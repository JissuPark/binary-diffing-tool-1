import idb
import timeit
import hashlib
import json
import errno
import os
import signal
import shutil
from multiprocessing import Queue, Process
from functools import wraps
import const_filter_indexs as _filter

C_END     = "\033[0m"
C_BOLD    = "\033[1m"
C_INVERSE = "\033[7m"
C_RED    = "\033[31m"
C_YELLOW = "\033[33m"

api = None
filename = None
imageBase = None
glo_MinEA = None
glo_MaxEA = None
campaign = None

#debug info
err_log = list()

def timeout(seconds=100, error_message="[Coercion] infinite loop detection"):
    def decorator(func):
        def _handle_timeout(signum, frame):
            raise TimeoutError(error_message)

        def wrapper(*args, **kwargs):
            signal.signal(signal.SIGALRM, _handle_timeout)
            signal.alarm(seconds)
            try:
                result = func(*args, **kwargs)
            finally:
                signal.alarm(0)
            return result

        return wraps(func)(wrapper)

    return decorator

@timeout(30)
def get_flow_chart(fva):
    global api

    FlowChart_info = api.idaapi.FlowChart(api.ida_funcs.get_func(fva))

    return FlowChart_info

@timeout(30)
def get_disasm(curaddr):
    return api.idc.GetDisasm(curaddr)

def extract_basic_block_info(fva, func_ext_dict, FROM_FILE):
    global api
    global imageBase
    global glo_MinEA
    global glo_MaxEA
    global campaign
    global filename
    try:
        FlowChart_info = get_flow_chart(fva)
        try:
            for BasicBlock in FlowChart_info:

                curaddr = BasicBlock.startEA
                endaddr = BasicBlock.endEA
                constants = list() # block level constans
                hex_opcodes = list() # block level opcodes to convert integer (str->hex->int)

                while curaddr < endaddr:
                    disasm = get_disasm(curaddr) #여기를 함수로 만들어서 타임아웃 걸기
                    cutNumber = disasm.find('\t')
                    opcode = disasm[:cutNumber] # block level 1 line opcode
                    operand = disasm[cutNumber:].replace('\t', '') # block level 1 line operand

                    '''--- constant value extraction ---'''
                    if operand == "": # 0-Address Instruction Filter
                        pass
                    else:
                        operand = operand.split(',')

                        if len(operand) == 1: # 1-Address Instruction Filter
                            if operand[0] not in _filter.reg and '[' not in operand[0]:
                                if '0x' in operand[0] and glo_MinEA <= int(operand[0], 16) <= glo_MaxEA:
                                        pass
                                elif operand[0] not in imageBase and operand[0] not in _filter.logic:
                                    constants.append(operand[0])

                        elif len(operand) == 2: # 2-Address Instruction Filter
                            operand_1, operand_2 = operand
                            operand_2 = operand_2[1:]

                            if operand_1 not in _filter.pointer:
                                if operand_2 not in _filter.reg and 'ptr' not in operand_2 and '[' not in operand_2:
                                    if '0x' in operand_2 and glo_MinEA <= int(operand_2, 16) <= glo_MaxEA:
                                        pass
                                    elif operand_2 not in imageBase and operand_2 not in _filter.logic:
                                        constants.append(operand_2)

                        else: # 3-Address Instruction exception
                            operand_1, operand_2, operand_3 = operand
                            operand_2 = operand_2[1:]

                            if operand_1 not in _filter.pointer and operand_2 not in _filter.pointer:

                                if operand_2 not in _filter.reg and 'ptr' not in operand_2 and '[' not in operand_2:
                                    if '0x' in operand_2 and glo_MinEA <= int(operand_2, 16) <= glo_MaxEA:
                                            pass
                                    elif operand_2 not in imageBase and operand_2 not in _filter.logic:
                                        constants.append(operand_2)

                                if operand_3 not in _filter.reg and 'ptr' not in operand_3 and '[' not in operand_3:
                                    if '0x' in operand_3 and glo_MinEA <= int(operand_3, 16) <= glo_MaxEA:
                                        pass
                                    elif operand_3 not in imageBase and operand_3 not in _filter.logic:
                                        constants.append(operand_3)
                    '''--- END constant value extraction ---'''
                    hex_opcodes.append(int(opcode.encode("utf-8").hex(), 16))
                    curaddr = api.idc.NextHead(curaddr)
                    del disasm, cutNumber, opcode, operand

                temp_const = ' '.join(constants)
                temp_hash = hashlib.sha256(hex(sum(hex_opcodes)).encode()).hexdigest()
                func_ext_dict[temp_hash] = dict()
                func_ext_dict[temp_hash] = {temp_const:{campaign:filename}}
                del temp_const, temp_hash
        except Exception as e:
            err_log.append("Extract_" + str(e))
    except Exception:
        print(C_BOLD+C_RED+"[Detection] =====> infinite loop sensing <===== "+C_END)
        print(C_BOLD+C_RED+f"ㄴ {filename}"+C_END)
        shutil.move(FROM_FILE, r"/mnt/c/ext/error/")
        print(C_BOLD+C_INVERSE+f"[MOVED] {filename} -> /mnt/c/ext/error/{filename}"+C_END)

def main(FROM_FILE):
    global api
    global filename
    global imageBase
    global glo_MaxEA
    global glo_MinEA
    global err_log

    func_ext_dict = dict() # functionn level extract info dict
    glo_MaxEA = int(hex(api.idc.MaxEA()), 16)
    glo_MinEA = int(hex(api.idc.MinEA()), 16)
    imageBase = _filter.imageBase
    imageBase.append(str(hex(api.idaapi.get_imagebase())))

    for fva in api.idautils.Functions():
        FuncName = api.idc.GetFunctionName(fva).lower()
        if "sub_" in FuncName or "start" in FuncName or "main" in FuncName or "dllentry" in FuncName:
            try:            
                extract_basic_block_info(fva, func_ext_dict, FROM_FILE)
            except Exception:
                pass
        del FuncName

    return func_ext_dict

def basicblock_info_extraction(FROM_FILE):
    global api
    api = open_idb(FROM_FILE)

    func_ext_dict = main(FROM_FILE)

    return func_ext_dict


def open_idb(FROM_FILE):
    global filename
    filename = FROM_FILE[FROM_FILE.rfind('/') + 1:-4]
    with idb.from_file(FROM_FILE) as db:
        api = idb.IDAPython(db)

        return api

def handle_mulit(q):
    global campaign

    sample_dir = r"/mnt/c/ext/cerber"
    output_dir = r"/mnt/c/ext/result"
    campaign = "cerber"

    while q.empty() != True:
        s = timeit.default_timer()
        FName = q.get()
        extract_info = basicblock_info_extraction(sample_dir + '/' + FName)

        with open(output_dir + '/' + filename + ".hash", 'w') as makefile:
            json.dump(extract_info, makefile, ensure_ascii=False, indent='\t')

        print(C_BOLD+C_YELLOW+f'[INFO] {FName} ===> {timeit.default_timer() - s}'+C_END)

if __name__ == "__main__":

    sample_dir = r"/mnt/c/ext/cerber"
    cpu = (os.cpu_count() // 2) + 1

    # Work listing
    q = Queue()
    for Name in os.listdir(sample_dir):
        q.put(Name)

    p_list = list()
    for i in range(cpu):
        p = Process(target= handle_mulit, args=[q])
        p_list.append(p)
        p.start()
    
    for p in p_list:
        p.join()
